from pydantic import BaseModel, EmailStr, Field
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum


class MessageType(str, Enum):
    INBOUND = "inbound"
    OUTBOUND = "outbound"
    INTERNAL_NOTE = "internal_note"


class ThreadStatus(str, Enum):
    OPEN = "open"
    PENDING_APPROVAL = "pending_approval"
    CLOSED = "closed"


class Priority(str, Enum):
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"


class QueryType(str, Enum):
    LEAVE_REQUEST = "leave_request"
    POLICY_QUESTION = "policy_question"
    COMPLAINT = "complaint"
    GENERAL_INQUIRY = "general_inquiry"
    PAYROLL = "payroll"
    BENEFITS = "benefits"
    TRAINING = "training"
    OTHER = "other"


# Email parsing models
class ParsedEmailQuery(BaseModel):
    """Structured output from AI email parser"""
    staff_name: str
    staff_email: EmailStr
    department: Optional[str] = None
    query_type: QueryType
    urgency_level: Priority
    
    # Main query details
    query_summary: str
    detailed_description: str
    
    # Extracted entities
    mentioned_dates: List[str] = []
    mentioned_people: List[str] = []
    policy_references: List[str] = []
    
    # Additional metadata
    sentiment: Optional[str] = None
    requires_ops_approval: bool = True
    suggested_actions: List[str] = []


class EmailSummary(BaseModel):
    """Summary generated by AI"""
    executive_summary: str
    key_points: List[str]
    action_items: List[str]
    risks_identified: List[str] = []
    recommended_response_tone: str = "professional"


# API Request/Response models
class EmailThreadCreate(BaseModel):
    subject: str
    staff_email: EmailStr
    staff_name: str
    query_type: Optional[QueryType] = None
    priority: Priority = Priority.NORMAL
    extracted_data: Optional[Dict[str, Any]] = None
    summary: Optional[str] = None


class EmailMessageCreate(BaseModel):
    thread_id: int
    sender: EmailStr
    recipients: List[EmailStr]
    cc: Optional[List[EmailStr]] = []
    subject: str
    body_text: str
    body_html: Optional[str] = None
    message_type: MessageType
    direction: str
    requires_approval: bool = False


class EmailReplyRequest(BaseModel):
    thread_id: int
    body: str
    recipients: List[EmailStr]
    cc: Optional[List[EmailStr]] = []
    requires_approval: bool = False
    is_html: bool = False


class EmailThreadResponse(BaseModel):
    id: int
    thread_id: str
    ticket_number: str
    subject: str
    status: ThreadStatus
    priority: Priority
    staff_email: str
    staff_name: str
    query_type: Optional[str]
    department: Optional[str]
    summary: Optional[str]
    created_at: datetime
    updated_at: Optional[datetime]
    message_count: int = 0
    last_message_date: Optional[datetime] = None
    
    class Config:
        from_attributes = True


class EmailMessageResponse(BaseModel):
    id: int
    thread_id: int
    message_id: str
    sender: str
    recipients: List[str]
    cc: List[str] = []
    subject: str
    body_text: str
    body_html: Optional[str]
    message_type: MessageType
    direction: str
    suggested_response: Optional[str]
    requires_approval: bool
    approved_by: Optional[str]
    approved_at: Optional[datetime]
    email_date: datetime
    created_at: datetime
    
    class Config:
        from_attributes = True


class ThreadListResponse(BaseModel):
    threads: List[EmailThreadResponse]
    total: int
    page: int
    page_size: int


class SuggestedResponse(BaseModel):
    thread_id: int
    message_id: int
    suggested_text: str
    confidence_score: float
    reasoning: str
    requires_modification: bool = False
    modification_suggestions: List[str] = [] 