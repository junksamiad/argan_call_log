import logging
from typing import Dict, List, Optional
from datetime import datetime
from sqlalchemy.orm import Session
from backend.services.email_service import EmailService
from backend.services.ai_service import AIService
from backend.models.database import EmailThread, EmailMessage, EmailAttachment
from backend.models.schemas import MessageType, ThreadStatus
import re

logger = logging.getLogger(__name__)


class EmailProcessor:
    def __init__(self, db_session: Session):
        self.db = db_session
        self.email_service = EmailService()
        self.ai_service = AIService()
        
    def process_new_emails(self):
        """Main method to fetch and process new emails"""
        try:
            # Fetch unread emails
            emails = self.email_service.fetch_unread_emails()
            logger.info(f"Found {len(emails)} new emails to process")
            
            for email_data in emails:
                try:
                    self._process_single_email(email_data)
                    # Mark as read after successful processing
                    self.email_service.mark_as_read(email_data['uid'])
                except Exception as e:
                    logger.error(f"Error processing email {email_data.get('subject', 'Unknown')}: {str(e)}")
                    continue
                    
            self.db.commit()
            
        except Exception as e:
            logger.error(f"Error in email processing: {str(e)}")
            self.db.rollback()
            raise
            
    def _process_single_email(self, email_data: Dict):
        """Process a single email"""
        # Check if it's part of existing thread
        thread_id = email_data.get('thread_id')
        
        if thread_id:
            # Add to existing thread
            thread = self.db.query(EmailThread).filter_by(ticket_number=thread_id).first()
            if thread:
                self._add_message_to_thread(thread, email_data)
                return
                
        # Create new thread
        self._create_new_thread(email_data)
        
    def _create_new_thread(self, email_data: Dict):
        """Create a new email thread"""
        # Parse email with AI
        parsed_query = self.ai_service.parse_email_query(
            email_data['body_text'],
            email_data['subject']
        )
        
        # Generate summary
        summary = self.ai_service.generate_summary(parsed_query, email_data['body_text'])
        
        # Create thread - ticket_number will be auto-generated by database
        thread = EmailThread(
            subject=email_data['subject'],
            staff_email=parsed_query.staff_email,
            staff_name=parsed_query.staff_name,
            query_type=parsed_query.query_type.value,
            department=parsed_query.department,
            priority=parsed_query.urgency_level.value,
            extracted_data=parsed_query.dict(),
            summary=summary.executive_summary,
            status=ThreadStatus.OPEN.value
        )
        self.db.add(thread)
        self.db.flush()  # Flush to get the auto-generated ticket_number
        
        # Generate suggested response
        suggested_response = self.ai_service.generate_response_suggestion(
            parsed_query, summary
        )
        
        # Create message
        message = EmailMessage(
            thread_id=thread.id,
            message_id=email_data['message_id'],
            sender=email_data['sender'],
            recipients=email_data['recipients'],
            cc=email_data.get('cc', []),
            subject=email_data['subject'],
            body_text=email_data['body_text'],
            body_html=email_data.get('body_html'),
            message_type=MessageType.INBOUND.value,
            direction='in',
            suggested_response=suggested_response,
            requires_approval=parsed_query.requires_ops_approval,
            email_date=email_data['email_date']
        )
        self.db.add(message)
        
        # Handle attachments
        for attachment in email_data.get('attachments', []):
            att = EmailAttachment(
                message_id=message.id,
                filename=attachment['filename'],
                content_type=attachment['content_type'],
                size=attachment['size']
            )
            self.db.add(att)
            
        logger.info(f"Created new thread {thread.ticket_number} for {thread.subject}")
        
    def _add_message_to_thread(self, thread: EmailThread, email_data: Dict):
        """Add a message to existing thread"""
        # Create message
        message = EmailMessage(
            thread_id=thread.id,
            message_id=email_data['message_id'],
            sender=email_data['sender'],
            recipients=email_data['recipients'],
            cc=email_data.get('cc', []),
            subject=email_data['subject'],
            body_text=email_data['body_text'],
            body_html=email_data.get('body_html'),
            message_type=MessageType.INBOUND.value,
            direction='in',
            email_date=email_data['email_date']
        )
        self.db.add(message)
        
        # Update thread status if needed
        if thread.status == ThreadStatus.CLOSED.value:
            thread.status = ThreadStatus.OPEN.value
            
        thread.updated_at = datetime.utcnow()
        
        logger.info(f"Added message to thread {thread.ticket_number}")
        
    def send_reply(self, thread_id: int, body: str, recipients: List[str], 
                   cc: List[str] = None, user_email: str = None) -> bool:
        """Send a reply for a thread"""
        try:
            thread = self.db.query(EmailThread).filter_by(id=thread_id).first()
            if not thread:
                raise ValueError(f"Thread {thread_id} not found")
                
            # Send email
            success = self.email_service.send_email(
                to=recipients,
                subject=thread.subject,
                body=body,
                cc=cc,
                thread_id=thread.ticket_number
            )
            
            if success:
                # Save to database
                message = EmailMessage(
                    thread_id=thread.id,
                    message_id=f"outbound-{datetime.utcnow().timestamp()}",
                    sender=user_email or self.email_service.email_address,
                    recipients=recipients,
                    cc=cc or [],
                    subject=thread.subject,
                    body_text=body,
                    message_type=MessageType.OUTBOUND.value,
                    direction='out',
                    email_date=datetime.utcnow()
                )
                self.db.add(message)
                thread.updated_at = datetime.utcnow()
                self.db.commit()
                
                logger.info(f"Reply sent for thread {thread.ticket_number}")
                return True
                
            return False
            
        except Exception as e:
            logger.error(f"Error sending reply: {str(e)}")
            self.db.rollback()
            return False 